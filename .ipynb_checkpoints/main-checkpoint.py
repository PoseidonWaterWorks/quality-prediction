{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import csv\n",
    "import matplotlib.pyplot as plt\n",
    "import IPython\n",
    "import os\n",
    "import zipfile\n",
    "import os\n",
    "import cv2\n",
    "import string\n",
    "import torch.nn as nn\n",
    "from sklearn.tree import export_graphviz\n",
    "import pydot\n",
    "import plotly.express as px\n",
    "import streamlit as st\n",
    "import seaborn as sns\n",
    "\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from torchvision import transforms, utils\n",
    "from torch import optim as optim, functional as F\n",
    "from torchvision.transforms import ToTensor\n",
    "from torch.nn.utils.rnn import pad_sequence\n",
    "from matplotlib import pyplot as plt, transforms\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "\n",
    "dataset = pd.read_csv('/Users/devpatelio/Downloads/Coding/Python/indigenous_water_crisis/water_potability.csv')\n",
    "df = dataset.replace(to_replace=np.nan, value=0)\n",
    "df.head()\n",
    "\n",
    "\n",
    "st.title(\"Posiedon Water Works\")\n",
    "st.markdown(\"Welcome to our attempt at making water quality transparent and easy to access for indigenous communities!\")\n",
    "\n",
    "st.header(\"Water Quality Metrics\")\n",
    "st.markdown(\"> We use key features like 'ph', 'Hardness', 'Solids', 'Chloramines', 'Sulfate', 'Conductivity', 'Organic_carbon', 'Trihalomethanes', and 'Turbidity' to calculate the quality of water with our state-of-the-art hardware coupled with our global informatics system that allows communities to easily identify and access water quality readings and thus redirect water flow accordingly.'\")\n",
    "\n",
    "# sns.heatmap(df)\n",
    "\n",
    "def normalize(vals, iter):\n",
    "    assert type(vals) is list\n",
    "    mm = min(iter)\n",
    "    mx = max(iter)\n",
    "\n",
    "    return [(i-mm)/(mx-mm) for i in vals]\n",
    "\n",
    "\n",
    "norm_df = pd.DataFrame()\n",
    "\n",
    "for i in df.iloc[:-1]:\n",
    "    list_data = df[i].to_list()\n",
    "    avg = normalize([sum(list_data)/len(list_data)], list_data)\n",
    "    norm_data = normalize(list_data, list_data)\n",
    "    norm_df[i] = norm_data\n",
    "\n",
    "norm_df.head()\n",
    "\n",
    "# print(norm_df.to_string())\n",
    "\n",
    "norm_df = norm_df.sample(frac=1).reset_index(drop=True)\n",
    "norm_df.head()\n",
    "\n",
    "\n",
    "\n",
    "x_train, x_test, y_train, y_test = train_test_split(norm_df.iloc[:,:-1], norm_df.iloc[:,-1])\n",
    "\n",
    "assert (len(x_train))==(len(y_train))\n",
    "assert (len(x_test))==(len(y_test))\n",
    "\n",
    "rfregression = RandomForestRegressor(n_estimators = 1000)\n",
    "rfregression.fit(x_train, y_train)\n",
    "\n",
    "preds = rfregression.predict(x_test)\n",
    "errors = abs(preds-y_test)\n",
    "\n",
    "error_log = []\n",
    "y_test_log = []\n",
    "error_log.append(np.mean(errors))\n",
    "y_test_log.append(np.mean(y_test))\n",
    "\n",
    "acc = 100 - np.mean(errors)/np.mean(y_test)\n",
    "print(f\"Accuracy: {acc}%\")\n",
    "\n",
    "print(list(norm_df.iloc[:, :-1]))\n",
    "tree = rfregression.estimators_[5]\n",
    "export_graphviz(tree, out_file = 'tree.dot', feature_names=list(norm_df.iloc[:, :-1]), precision=1)\n",
    "(graph, ) = pydot.graph_from_dot_file('tree.dot')\n",
    "importances = list(rfregression.feature_importances_)\n",
    "feat_importance = [(norm_df, round(importance, 2)) for feature, importance in zip(list(norm_df.iloc[:, :-1]), importances)]\n",
    "feat_importance = sorted(feat_importance, key=lambda x: x[1], reverse=True)\n",
    "\n",
    "print(*[f\"Name: {list(norm_df.iloc[:, :-1])[idx]}, Importance: {feat_importance[idx][-1]}\" for idx in range(len(feat_importance))])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
